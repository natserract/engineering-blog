---
title: Projects
blocks:
  - body: "# **Projects**\n\nList of projects what I've worked on. Mostly OSS\n\n## Sigi Tour Transport\n\nJawa Bali, Bus ticket order app. Deployed on vercel with ported external domain (domainesia). The application is built on top of NextJS13, and prioritizes mobile first with PWA. Backend using NodeJS, and PostgreSQL as a main database. Support online payment using Xendit as payment gateway.\\\n\\\nI Work as a team lead to handle all technical and team issues, then communicate with clients directly\\\n\\\n**Challenges**:\n\n* Do reverse engineering approach to get the provider API from each provider application, because this application is sourced from X agent who has registered (privately) and wants to have their own App to accelerate sales, instead of manually.\n* Ticket booking race condition\n\nTech Stacks: NextJS13, React Query, Multithread, Koa.js, PostgreSQL, Xendit, Zod, TypeScript, TurboRepo, PWA, Sequelize, Async Mutex, Android Development, Sentry\n\nSite: [https://app.sigitourtransport.com/](https://app.sigitourtransport.com/)\_\n\n(Try to reload again if you found req timeout, some limitation problem [https://vercel.com/docs/limits/overview](https://vercel.com/docs/limits/overview))\n\n## XState\n\nXState is a State Machine library for Elixir. The goal of XState to make state machines easy and flexible to use, without requiring developers to messy with gen server process, focus on state transitions instead.\n\nXState provides a simple API for defining states and transitions. Developers can focus on modeling state machines. XState aims to be beginner-friendly, and uses finite-state-machine concepts in its implementation.\n\n**Challenges**:\n\n* Sharing state with other process\n* External State from outside a machine\n* Nested dynamic keys\n* API Design\n\nTech Stacks: Elixir, State machine knowledge, Actor Model, Dialyxir\n\nSite: [https://hex.pm/packages/xstate](https://hex.pm/packages/xstate)\n\n## Reason Rust Scraper\n\nAn experimental data scraping project in Rust. As a low-level, statically typed, compiled, non-garbage collected language, Rust prioritizes speed and control. These features make Rust well-suited for data scraping.\n\nThis project let me explore Rust's potential for web scraping. I chose Rust over other languages like Python because performance matters in scraping large datasets. Rust's lack of a garbage collector also gives more predictability over memory usage.\n\n**Challenges**:\n\n* Low level approach\n* Performance, speed concerns\n* Rust compiler\n\nTech Stacks: Rust, Reqwest, ReasonML, Diesel\n\nSite: [https://github.com/natserract/reason-rust-scraper/tree/master](https://github.com/natserract/reason-rust-scraper/tree/master)\n\n## Use Recursive Fetch Paginate\_\n\nReact hook for handles fetching data recursively from a paginated API. The hook was originally designed for internal needs, but its functionality could be adapted for general use.\n\nThe backend API would need to support parameters like offset and limit that this hook relies on for pagination. With some API tweaking, this hook could provide a clean way for React developers to load paginated data.\n\nBy recursing through the pages, it prevents the need to manually handle each page fetch. This keeps component logic simple. The hook encapsulates the pagination logic from the UI code. Developers using this hook only need to specify how to fetch each page. The hook handles the rest.\n\n**Challenges**:\n\n* Memory leaks issue\n* Asynchronous operations\n\nTech Stacks: React Hook, TypeScript, Type Sytems knowledge\n\nSite: [https://www.npmjs.com/package/use-recursive-fetch-paginate](https://www.npmjs.com/package/use-recursive-fetch-paginate)\n\n## CDD React\n\nProject demo shows how I built React components from scratch using the Component-Driven Development (CDD) approach with focuses on creating robust, performant, and type-safe components.\n\nFollowing best practices like cohesion and separation of concerns. Each component has a clear purpose and handles a discrete task. This makes the components reusable, testable, and maintainable. The result is a modular codebase where components can be quickly understood, modified, and rearranged as needed.\n\nCDD encourages building UIs flexibly while avoiding tightly coupled or duplicated logic. This project demonstrates the strengths of CDD for crafting robust React apps one component at a time.\n\n**Challenges**:\n\n* Component driven development\n* DX priority\n\nTech Stacks: Component driven, React, TypeScript, StyledComponents\n\nSite: [https://github.com/natserract/cdd-react](https://github.com/natserract/cdd-react)\n\n## Local Storage Observer\_\n\nTypescript library for handles local storage in an Observer pattern to enable reactive reading of changes from external stores like local storage. This overcomes limitations of the Storage event API, which does not detect changes made on the same page.\n\nBy implementing an Observer pattern with local storage as the subject, this library can monitor changes to local storage made externally and propagate those changes through the observer instances.\n\n**Challenges**:\n\n* Cache invalidation\n* Data serializing and deserializing\n* Observable pattern\n\nTech Stacks: RxJS, TypeScript\n\nSite: [https://www.npmjs.com/package/local-storage-observer](https://www.npmjs.com/package/local-storage-observer)\n\n## Rust Git Hooks\n\nAn experimental project implements a Git hooks workflow using Rust. The project explores several APIs:\n\n* Commit logging allows tracking changes to the codebase over time. Each commit gets logged with metadata like the author, date, and commit message.\n* Branch management APIs enable creating, renaming, and deleting branches.\_\n\nThe project focuses on leveraging Rust's performance and safety to build robust Git hooks. These hooks run custom logic during Git actions like committing code or pushing branches. For example, a pre-commit hook could lint changed files before accepting a commit.\n\n**Challenges**:\n\n* Asynchronous programming\n* Rust Ownership\n\nTech stacks: Rust, Futures\n\nSite: [https://github.com/natserract/rust-git-hooks](https://github.com/natserract/rust-git-hooks)\n\n## Predict Sugar\n\nAn experimental library that provide syntatic sugar for if-else statements. The goals of this library are to enable consistent return types, and a cleaner syntax.\n\nChallenges:\n\n* OOP design\_\n* Polymorphism data type\n* Reinventing the wheel problems\n\nTech Stacks: TypeScript, Type System knowledge\n\nSite: [https://www.npmjs.com/package/predict-sugar](https://www.npmjs.com/package/predict-sugar)\n\n## Breath\n\nCLI for generate page/components base on Templates built on top using shell script.\n\nChallenges:\n\n* Shell script environment vars\n* Shell script limitation\n\nTech Stacks: Shell script\n\nSite: [https://github.com/natserract/breath/tree/master](https://github.com/natserract/breath/tree/master)\n"
    _template: content
---

